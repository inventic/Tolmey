/*jshint node:true laxcomma:true laxbreak:true*/
// (C) Jamison Dance (jergason) 2011
// MIT License

(function() {
  "use strict";

  var strategies = require('./strategies')
    ;

  // for kicks
  Object.keys(strategies).forEach(function (key) {
    strategies[key.toLowerCase()] = strategies[key];
  });

  function toRad(n) {
    return n * (Math.PI / 180);
  }

  function toDeg(n) {
    return n * (180 / Math.PI);
  }

  //Add math trig functions
  if (typeof(Math.atanh) === "undefined") {
    Math.atanh = function (x) {
      return 0.5 * Math.log((1 + x) / (1 - x));
    };
  }

  if (typeof(Math.tanh) === "undefined") {
    Math.tanh = function (x) {
      return (Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1);
    };
  }


  function Tolmey(opts) {
    var TILESIZE
      , RADIUS_OF_EARTH_IN_METERS
      ;

    RADIUS_OF_EARTH_IN_METERS = 6378100;
    if (!opts) {
      opts = {};
    }

    if (!opts.tileSize) {
      //Default tile size in pixels
      opts.tileSize = 256;
    }

    TILESIZE = opts.tileSize;

    function modGPSAdd(x, y) {
      var res = x + y;
      if (res > 180) {
        while (res > 180) {
          res = res - 360;
        }
      }
      else if (res < -180) {
        while (res < -180) {
          res = res + 360;
        }
      }
      return res;
    }

    function haversineFunction(lat_start, long_start, lat_end, long_end) {
      var dLat = toRad(lat_end - lat_start)
        , dLon = toRad(long_end - long_start)
        , lat1 = toRad(lat_start)
        , lat2 = toRad(lat_end)
        ;

      var a = Math.pow(Math.sin(dLat/2), 2) + Math.cos(lat1)*Math.cos(lat2)*Math.pow(Math.sin(dLon/2),2);
      var centralAngle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return centralAngle;
    }


    return {
      // Returns an array of tile urls covering a square generated by a given width
      // centered on a given point for a given mapping system.
      // The array is indexed by zoom level, so urls[15] is all the URLs for tiles that cover the area
      // in zoom level 15, ect.
      getTileURLs: function (opts) {
        var coords = this.getTileCoords(opts)
          , mappingSystem = "openstreetmap"
          , urls = {}
          ;

        if (opts.hasOwnProperty("mappingSystem")) {
          mappingSystem = opts.mappingSystem;
        }

        Object.keys(coords).forEach(function (zoom) {
          var coord = coords[zoom]
            ;

          urls[zoom] = urls[zoom] || [];
          urls[zoom].push({
              url: this.getTileURL(mappingSystem, coord.x, coord.y, coord.zoom)
            , coords: coord
          });
        });

        return urls;
      },

      getTileCoords: function (opts) {
        var north = this.translate(opts.lat, opts.lon, opts.radius, 0)
          , south = this.translate(opts.lat, opts.lon, opts.radius, 180)
          , west = this.translate(opts.lat, opts.lon, opts.radius, 270)
          , east = this.translate(opts.lat, opts.lon, opts.radius, 90)
          , urls = []
          , origin
          , i, j, z, y0, y1, x0, x1
          , zoom = 12
          , maxZoom = 20
          ;

        if (opts.hasOwnProperty("zoom")) {
          zoom = opts.zoom;
        }
        if (opts.hasOwnProperty("maxZoom")) {
          maxZoom = opts.maxZoom;
        }

        for (i = 0; i <= maxZoom; i++) {
          urls[i] = [];
        }


        for (zoom; zoom <= maxZoom; zoom += 1) {
          y0 = this.getMercatorFromGPS(north.latitude, north.longitude, zoom);
          y1 = this.getMercatorFromGPS(south.latitude, south.longitude, zoom);
          x0 = this.getMercatorFromGPS(west.latitude, west.longitude, zoom);
          x1 = this.getMercatorFromGPS(east.latitude, east.longitude, zoom);

          for (i = x0.x; i <= x1.x; i += 1) {
            for (j = y0.y; j <= y1.y; j += 1) {
              urls[zoom].push({
                  zoom: zoom
                , x: i
                , y: j
              });
            }
          }
        }

        return urls;
      },

      translate: function (lat, lon, d, brng) {
        var R = RADIUS_OF_EARTH_IN_METERS
          , lat2
          , lon2
          , ret
          ;

        lat = toRad(lat);
        lon = toRad(lon);
        brng = toRad(brng);

        lat2 = Math.asin(Math.sin(lat) * Math.cos(d/R) +
                         Math.cos(lat) * Math.sin(d/R) * Math.cos(brng));

        lon2 = lon + Math.atan2(Math.sin(brng) * Math.sin(d/R) * Math.cos(lat),
                                Math.cos(d/R) - Math.sin(lat) * Math.sin(lat2));

        lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;

        ret = {
            latitude: toDeg(lat2)
          , longitude: toDeg(lon2)
        };
        return ret;
      },


      distanceInMeters: function (lat_start, long_start, lat_end, long_end) {
        var central_angle_in_radians = haversineFunction(lat_start, long_start, lat_end, long_end);
        return central_angle_in_radians * RADIUS_OF_EARTH_IN_METERS;
      },


      getMercatorFromGPS: function (lat, lon, zoom) {
        var pixel_x = this.lonToXPixels(toRad(lon), zoom);
        var pixel_y = this.latToYPixels(toRad(lat), zoom);
        var max_pixel = Math.pow(2, zoom) * TILESIZE;

        if (pixel_x < 0) {
          pixel_x += max_pixel;
        }
        else if (pixel_x > max_pixel) {
          pixel_x -= max_pixel;
        }

        var tile_x = Math.floor(pixel_x / TILESIZE);
        var tile_y = Math.floor(pixel_y / TILESIZE);
        if (tile_x >= Math.pow(2, zoom)) {
          tile_x -= Math.pow(2, zoom);
        }

        return { x: tile_x, y: tile_y };
      },

      getTileURL: function (mapping_system, x, y, zoom) {
        var strategy = strategies[mapping_system.toLowerCase()]
          ;

        console.warn("[deprecated]: getTileURL has been replaced by 'strategies'");

        return strategy({
            x: x
          , y: y
          , zoom: zoom
        }, 0); // 0 because caching is more important than load balancing for this case
        // TODO download first, then show
      },

      // Takes lat in radians and a zoom, and returns a y pixel
      latToYPixels: function (lat, zoom) {
        var lat_m = Math.atanh(Math.sin(lat));
        var pixel_y = -( (lat_m * TILESIZE * Math.exp(zoom * Math.log(2)) ) / (2 * Math.PI)) +
          (Math.exp(zoom * Math.log(2)) * (TILESIZE/2) );
        return Math.floor(pixel_y);
      },

      // Takes the longitude in radians and tile zoom, and returns an x pixel.
      lonToXPixels: function (lon, zoom) {
        var pixel_x = ( (lon * TILESIZE * Math.exp(zoom * Math.log(2)) ) / (2*Math.PI) ) +
          ( Math.exp(zoom * Math.log(2)) * (TILESIZE/2) );
        return Math.floor(pixel_x);
      },

      latLonToPixel: function (lat, lon, zoom) {
        return { x: this.lonToXPixels(lon, zoom), y: this.latToYPixels(lat, zoom) };
      },

      xPixelToLon: function (xPixel, zoom) {
        var lon = ((xPixel - ( Math.exp(zoom * Math.log(2)) * (TILESIZE / 2))) * 2 * Math.PI) /
          (TILESIZE * Math.exp(zoom * Math.log(2)));
        return lon;
      },

      yPixelToLat: function (yPixel, zoom) {
        var latM = (-( yPixel - ( Math.exp(zoom * Math.log(2)) * (TILESIZE / 2))) * (2 * Math.PI)) / (TILESIZE * Math.exp(zoom * Math.log(2)));
        var lat = Math.atan(Math.tanh(latM));
        return lat;
      },

      getCircumferenceInTiles: function (zoom_level) {
        return Math.pow(2, zoom_level);
      },

      getMetersPerPixel: function (zoom_level, latitude) {
        if (zoom_level < 0) {
          zoom_level = 0;
        }
        if (latitude > 85.05 || latitude < -85.05) {
          throw new Error("Mercator projection is not valid outside of [-85.05, 85.05].");
        }
        return (Math.cos(latitude * (Math.PI / 180)) * 2 * Math.PI * RADIUS_OF_EARTH_IN_METERS) /
          (TILESIZE * this.getCircumferenceInTiles(zoom_level));
      },

      // --funroll-loops
      getFlatTileCoords: function (coords) {
        var tilez = this.getTileCoords(coords)
          , tiles = []
          ;

        tilez.forEach(function (tiless) {
          tiless.forEach(function (tile) {
            tiles.push(tile);
          });
        });

        return tiles;
      },

      // Taken from http://www.movable-type.co.uk/scripts/latlong.html.
      // Latitude/longitude spherical geodesy formulae & scripts (c) Chris Veness 2002-2011
      intersection: function(lat1, lon1, brng1, lat2, lon2, brng2) {
        var dLat
          , dLon
          , dist12
          , dist13
          , brngA
          , brngB
          , brng12
          , brng21
          , brng23
          , alpha1
          , alpha2
          , alpha3
          , dist13
          , dist23
          , lat3
          , lon3
          , dLon13
          ;

        lat1 = toRad(lat1);
        lon1 = toRad(lon1);
        lat2 = toRad(lat2);
        lon2 = toRad(lon2);
        brng1 = toRad(brng1);
        brng2 = toRad(brng2);

        dLat = lat2-lat1, dLon = lon2-lon1;

        dist12 = 2*Math.asin( Math.sqrt( Math.sin(dLat/2)*Math.sin(dLat/2) +
                                        Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)*Math.sin(dLon/2) ) );
        if (dist12 == 0) {
          return null;
        }

        // initial/final bearings between points
        brngA = Math.acos( ( Math.sin(lat2) - Math.sin(lat1)*Math.cos(dist12) ) /
                         ( Math.sin(dist12)*Math.cos(lat1) ) );
        if (isNaN(brngA)) {
          brngA = 0;  // protect against rounding
        }
        brngB = Math.acos( ( Math.sin(lat1) - Math.sin(lat2)*Math.cos(dist12) ) /
                         ( Math.sin(dist12)*Math.cos(lat2) ) );

        if (Math.sin(lon2-lon1) > 0) {
          brng12 = brngA;
          brng21 = 2*Math.PI - brngB;
        }
        else {
          brng12 = 2*Math.PI - brngA;
          brng21 = brngB;
        }

        alpha1 = (brng1 - brng12 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 2-1-3
        alpha2 = (brng21 - brng2 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 1-2-3


        if (Math.sin(alpha1)==0 && Math.sin(alpha2)==0) {
          // infinite intersections
          return null;
        }
        if (Math.sin(alpha1)*Math.sin(alpha2) < 0) {
          // ambiguous intersection
          return null;
        }

        alpha3 = Math.acos( -Math.cos(alpha1)*Math.cos(alpha2) +
                           Math.sin(alpha1)*Math.sin(alpha2)*Math.cos(dist12) );
        dist13 = Math.atan2( Math.sin(dist12)*Math.sin(alpha1)*Math.sin(alpha2),
                            Math.cos(alpha2)+Math.cos(alpha1)*Math.cos(alpha3) )
        lat3 = Math.asin( Math.sin(lat1)*Math.cos(dist13) +
                         Math.cos(lat1)*Math.sin(dist13)*Math.cos(brng1) );
        dLon13 = Math.atan2( Math.sin(brng1)*Math.sin(dist13)*Math.cos(lat1),
                            Math.cos(dist13)-Math.sin(lat1)*Math.sin(lat3) );
        lon3 = lon1+dLon13;
        lon3 = (lon3+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º

        return { latitude: toDeg(lat3), longitude: toDeg(lon3) };
      },

      strategies: strategies
    };
  }

  function create() {
    return Tolmey();
  }

  module.exports.create = create;
}());
